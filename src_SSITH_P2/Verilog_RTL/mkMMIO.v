//
// Generated by Bluespec Compiler, version 2019.05.beta2 (build a88bf40db, 2019-05-24)
//
//
//
//
// Ports:
// Name                         I/O  size props
// RDY_req                        O     1 const
// RDY_start                      O     1 const
// result_fst                     O     1 reg
// RDY_result_fst                 O     1
// result_snd_fst                 O    64 reg
// RDY_result_snd_fst             O     1
// result_snd_snd                 O    64 reg
// RDY_result_snd_snd             O     1
// g_mem_req_get                  O    67 reg
// RDY_g_mem_req_get              O     1 reg
// g_write_data_get               O    64 reg
// RDY_g_write_data_get           O     1 reg
// RDY_p_mem_read_data_put        O     1 reg
// CLK                            I     1 clock
// RST_N                          I     1 reset
// req_mmu_cache_req              I   208 reg
// start_pa                       I    64 reg
// p_mem_read_data_put            I    65 reg
// EN_req                         I     1
// EN_start                       I     1
// EN_p_mem_read_data_put         I     1
// EN_g_mem_req_get               I     1
// EN_g_write_data_get            I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkMMIO(CLK,
	      RST_N,

	      req_mmu_cache_req,
	      EN_req,
	      RDY_req,

	      start_pa,
	      EN_start,
	      RDY_start,

	      result_fst,
	      RDY_result_fst,

	      result_snd_fst,
	      RDY_result_snd_fst,

	      result_snd_snd,
	      RDY_result_snd_snd,

	      EN_g_mem_req_get,
	      g_mem_req_get,
	      RDY_g_mem_req_get,

	      EN_g_write_data_get,
	      g_write_data_get,
	      RDY_g_write_data_get,

	      p_mem_read_data_put,
	      EN_p_mem_read_data_put,
	      RDY_p_mem_read_data_put);
  input  CLK;
  input  RST_N;

  // action method req
  input  [207 : 0] req_mmu_cache_req;
  input  EN_req;
  output RDY_req;

  // action method start
  input  [63 : 0] start_pa;
  input  EN_start;
  output RDY_start;

  // value method result_fst
  output result_fst;
  output RDY_result_fst;

  // value method result_snd_fst
  output [63 : 0] result_snd_fst;
  output RDY_result_snd_fst;

  // value method result_snd_snd
  output [63 : 0] result_snd_snd;
  output RDY_result_snd_snd;

  // actionvalue method g_mem_req_get
  input  EN_g_mem_req_get;
  output [66 : 0] g_mem_req_get;
  output RDY_g_mem_req_get;

  // actionvalue method g_write_data_get
  input  EN_g_write_data_get;
  output [63 : 0] g_write_data_get;
  output RDY_g_write_data_get;

  // action method p_mem_read_data_put
  input  [64 : 0] p_mem_read_data_put;
  input  EN_p_mem_read_data_put;
  output RDY_p_mem_read_data_put;

  // signals for module outputs
  wire [66 : 0] g_mem_req_get;
  wire [63 : 0] g_write_data_get, result_snd_fst, result_snd_snd;
  wire RDY_g_mem_req_get,
       RDY_g_write_data_get,
       RDY_p_mem_read_data_put,
       RDY_req,
       RDY_result_fst,
       RDY_result_snd_fst,
       RDY_result_snd_snd,
       RDY_start,
       result_fst;

  // register rg_err
  reg rg_err;
  wire rg_err$D_IN, rg_err$EN;

  // register rg_final_st_val
  reg [63 : 0] rg_final_st_val;
  wire [63 : 0] rg_final_st_val$D_IN;
  wire rg_final_st_val$EN;

  // register rg_fsm_state
  reg [1 : 0] rg_fsm_state;
  reg [1 : 0] rg_fsm_state$D_IN;
  wire rg_fsm_state$EN;

  // register rg_ld_val
  reg [63 : 0] rg_ld_val;
  wire [63 : 0] rg_ld_val$D_IN;
  wire rg_ld_val$EN;

  // register rg_pa
  reg [63 : 0] rg_pa;
  wire [63 : 0] rg_pa$D_IN;
  wire rg_pa$EN;

  // register rg_req
  reg [207 : 0] rg_req;
  wire [207 : 0] rg_req$D_IN;
  wire rg_req$EN;

  // ports of submodule f_read_data
  wire [64 : 0] f_read_data$D_IN, f_read_data$D_OUT;
  wire f_read_data$CLR,
       f_read_data$DEQ,
       f_read_data$EMPTY_N,
       f_read_data$ENQ,
       f_read_data$FULL_N;

  // ports of submodule f_single_reqs
  reg [66 : 0] f_single_reqs$D_IN;
  wire [66 : 0] f_single_reqs$D_OUT;
  wire f_single_reqs$CLR,
       f_single_reqs$DEQ,
       f_single_reqs$EMPTY_N,
       f_single_reqs$ENQ,
       f_single_reqs$FULL_N;

  // ports of submodule f_write_data
  wire [63 : 0] f_write_data$D_IN, f_write_data$D_OUT;
  wire f_write_data$CLR,
       f_write_data$DEQ,
       f_write_data$EMPTY_N,
       f_write_data$ENQ,
       f_write_data$FULL_N;

  // rule scheduling signals
  wire CAN_FIRE_RL_rl_AMO_SC,
       CAN_FIRE_RL_rl_read_req,
       CAN_FIRE_RL_rl_read_rsp,
       CAN_FIRE_RL_rl_write_req,
       CAN_FIRE_g_mem_req_get,
       CAN_FIRE_g_write_data_get,
       CAN_FIRE_p_mem_read_data_put,
       CAN_FIRE_req,
       CAN_FIRE_start,
       WILL_FIRE_RL_rl_AMO_SC,
       WILL_FIRE_RL_rl_read_req,
       WILL_FIRE_RL_rl_read_rsp,
       WILL_FIRE_RL_rl_write_req,
       WILL_FIRE_g_mem_req_get,
       WILL_FIRE_g_write_data_get,
       WILL_FIRE_p_mem_read_data_put,
       WILL_FIRE_req,
       WILL_FIRE_start;

  // inputs to muxes for submodule ports
  wire [66 : 0] MUX_f_single_reqs$enq_1__VAL_1,
		MUX_f_single_reqs$enq_1__VAL_3;
  wire [63 : 0] MUX_f_write_data$enq_1__VAL_1,
		MUX_f_write_data$enq_1__VAL_2,
		MUX_rg_ld_val$write_1__VAL_1;
  wire MUX_f_single_reqs$enq_1__SEL_1, MUX_rg_ld_val$write_1__SEL_1;

  // remaining internal signals
  reg [63 : 0] _theResult_____2__h1449, mask__h1023, y__h1254;
  reg CASE_rg_req_BITS_204_TO_203_0b0_ld_val_bits89__ETC__q2;
  wire [63 : 0] IF_rg_req_BITS_204_TO_203_8_EQ_0b10_4_THEN_SEX_ETC___d80,
		data1__h978,
		data__h1908,
		final_ld_val__h1356,
		final_st_val__h1357,
		final_st_val__h1473,
		final_st_val__h1563,
		final_st_val__h1641,
		final_st_val__h1645,
		final_st_val__h1649,
		final_st_val__h1653,
		final_st_val__h1658,
		final_st_val__h1664,
		final_st_val__h1669,
		ld_val__h870,
		ld_val_bits__h789,
		result__h1242,
		result__h1314,
		w1___1__h1532,
		w1__h1442,
		w2___1__h1533,
		w2__h1444;
  wire [31 : 0] ld_val_bits89_BITS_31_TO_0__q1, rg_req_BITS_106_TO_75__q3;
  wire [5 : 0] shamt_bits__h1918;

  // action method req
  assign RDY_req = 1'd1 ;
  assign CAN_FIRE_req = 1'd1 ;
  assign WILL_FIRE_req = EN_req ;

  // action method start
  assign RDY_start = 1'd1 ;
  assign CAN_FIRE_start = 1'd1 ;
  assign WILL_FIRE_start = EN_start ;

  // value method result_fst
  assign result_fst = rg_err ;
  assign RDY_result_fst = rg_fsm_state == 2'd0 ;

  // value method result_snd_fst
  assign result_snd_fst = rg_ld_val ;
  assign RDY_result_snd_fst = rg_fsm_state == 2'd0 ;

  // value method result_snd_snd
  assign result_snd_snd = rg_final_st_val ;
  assign RDY_result_snd_snd = rg_fsm_state == 2'd0 ;

  // actionvalue method g_mem_req_get
  assign g_mem_req_get = f_single_reqs$D_OUT ;
  assign RDY_g_mem_req_get = f_single_reqs$EMPTY_N ;
  assign CAN_FIRE_g_mem_req_get = f_single_reqs$EMPTY_N ;
  assign WILL_FIRE_g_mem_req_get = EN_g_mem_req_get ;

  // actionvalue method g_write_data_get
  assign g_write_data_get = f_write_data$D_OUT ;
  assign RDY_g_write_data_get = f_write_data$EMPTY_N ;
  assign CAN_FIRE_g_write_data_get = f_write_data$EMPTY_N ;
  assign WILL_FIRE_g_write_data_get = EN_g_write_data_get ;

  // action method p_mem_read_data_put
  assign RDY_p_mem_read_data_put = f_read_data$FULL_N ;
  assign CAN_FIRE_p_mem_read_data_put = f_read_data$FULL_N ;
  assign WILL_FIRE_p_mem_read_data_put = EN_p_mem_read_data_put ;

  // submodule f_read_data
  FIFO2 #(.width(32'd65), .guarded(32'd1)) f_read_data(.RST(RST_N),
						       .CLK(CLK),
						       .D_IN(f_read_data$D_IN),
						       .ENQ(f_read_data$ENQ),
						       .DEQ(f_read_data$DEQ),
						       .CLR(f_read_data$CLR),
						       .D_OUT(f_read_data$D_OUT),
						       .FULL_N(f_read_data$FULL_N),
						       .EMPTY_N(f_read_data$EMPTY_N));

  // submodule f_single_reqs
  FIFO2 #(.width(32'd67), .guarded(32'd1)) f_single_reqs(.RST(RST_N),
							 .CLK(CLK),
							 .D_IN(f_single_reqs$D_IN),
							 .ENQ(f_single_reqs$ENQ),
							 .DEQ(f_single_reqs$DEQ),
							 .CLR(f_single_reqs$CLR),
							 .D_OUT(f_single_reqs$D_OUT),
							 .FULL_N(f_single_reqs$FULL_N),
							 .EMPTY_N(f_single_reqs$EMPTY_N));

  // submodule f_write_data
  FIFO2 #(.width(32'd64), .guarded(32'd1)) f_write_data(.RST(RST_N),
							.CLK(CLK),
							.D_IN(f_write_data$D_IN),
							.ENQ(f_write_data$ENQ),
							.DEQ(f_write_data$DEQ),
							.CLR(f_write_data$CLR),
							.D_OUT(f_write_data$D_OUT),
							.FULL_N(f_write_data$FULL_N),
							.EMPTY_N(f_write_data$EMPTY_N));

  // rule RL_rl_read_req
  assign CAN_FIRE_RL_rl_read_req =
	     f_single_reqs$FULL_N && rg_fsm_state == 2'd1 &&
	     rg_req[207:206] != 2'd1 &&
	     (rg_req[207:206] != 2'd2 || rg_req[74:70] != 5'b00011) ;
  assign WILL_FIRE_RL_rl_read_req = CAN_FIRE_RL_rl_read_req ;

  // rule RL_rl_read_rsp
  assign CAN_FIRE_RL_rl_read_rsp =
	     f_read_data$EMPTY_N &&
	     (!f_read_data$D_OUT[64] || rg_req[207:206] == 2'd0 ||
	      rg_req[207:206] == 2'd2 && rg_req[74:70] == 5'b00010 ||
	      f_single_reqs$FULL_N && f_write_data$FULL_N) &&
	     rg_fsm_state == 2'd2 ;
  assign WILL_FIRE_RL_rl_read_rsp = CAN_FIRE_RL_rl_read_rsp ;

  // rule RL_rl_write_req
  assign CAN_FIRE_RL_rl_write_req =
	     f_single_reqs$FULL_N && f_write_data$FULL_N &&
	     rg_fsm_state == 2'd1 &&
	     rg_req[207:206] == 2'd1 ;
  assign WILL_FIRE_RL_rl_write_req = CAN_FIRE_RL_rl_write_req ;

  // rule RL_rl_AMO_SC
  assign CAN_FIRE_RL_rl_AMO_SC =
	     rg_fsm_state == 2'd1 && rg_req[207:206] == 2'd2 &&
	     rg_req[74:70] == 5'b00011 ;
  assign WILL_FIRE_RL_rl_AMO_SC = CAN_FIRE_RL_rl_AMO_SC ;

  // inputs to muxes for submodule ports
  assign MUX_f_single_reqs$enq_1__SEL_1 =
	     WILL_FIRE_RL_rl_read_rsp && f_read_data$D_OUT[64] &&
	     rg_req[207:206] != 2'd0 &&
	     (rg_req[207:206] != 2'd2 || rg_req[74:70] != 5'b00010) ;
  assign MUX_rg_ld_val$write_1__SEL_1 =
	     WILL_FIRE_RL_rl_read_rsp && f_read_data$D_OUT[64] ;
  assign MUX_f_single_reqs$enq_1__VAL_1 = { 1'd0, rg_pa, rg_req[204:203] } ;
  assign MUX_f_single_reqs$enq_1__VAL_3 = { 1'd1, rg_pa, rg_req[204:203] } ;
  assign MUX_f_write_data$enq_1__VAL_1 =
	     final_st_val__h1357 << shamt_bits__h1918 ;
  assign MUX_f_write_data$enq_1__VAL_2 = data__h1908 << shamt_bits__h1918 ;
  assign MUX_rg_ld_val$write_1__VAL_1 =
	     (rg_req[207:206] == 2'd0 ||
	      rg_req[207:206] == 2'd2 && rg_req[74:70] == 5'b00010) ?
	       ld_val__h870 :
	       final_ld_val__h1356 ;

  // register rg_err
  assign rg_err$D_IN = !EN_req ;
  assign rg_err$EN =
	     WILL_FIRE_RL_rl_read_rsp && !f_read_data$D_OUT[64] || EN_req ;

  // register rg_final_st_val
  assign rg_final_st_val$D_IN =
	     MUX_f_single_reqs$enq_1__SEL_1 ?
	       final_st_val__h1357 :
	       rg_req[138:75] ;
  assign rg_final_st_val$EN =
	     WILL_FIRE_RL_rl_read_rsp && f_read_data$D_OUT[64] &&
	     rg_req[207:206] != 2'd0 &&
	     (rg_req[207:206] != 2'd2 || rg_req[74:70] != 5'b00010) ||
	     WILL_FIRE_RL_rl_write_req ;

  // register rg_fsm_state
  always@(EN_start or
	  WILL_FIRE_RL_rl_AMO_SC or
	  WILL_FIRE_RL_rl_write_req or
	  WILL_FIRE_RL_rl_read_rsp or WILL_FIRE_RL_rl_read_req)
  case (1'b1)
    EN_start: rg_fsm_state$D_IN = 2'd1;
    WILL_FIRE_RL_rl_AMO_SC || WILL_FIRE_RL_rl_write_req ||
    WILL_FIRE_RL_rl_read_rsp:
	rg_fsm_state$D_IN = 2'd0;
    WILL_FIRE_RL_rl_read_req: rg_fsm_state$D_IN = 2'd2;
    default: rg_fsm_state$D_IN = 2'b10 /* unspecified value */ ;
  endcase
  assign rg_fsm_state$EN =
	     WILL_FIRE_RL_rl_AMO_SC || WILL_FIRE_RL_rl_write_req ||
	     WILL_FIRE_RL_rl_read_rsp ||
	     EN_start ||
	     WILL_FIRE_RL_rl_read_req ;

  // register rg_ld_val
  assign rg_ld_val$D_IN =
	     MUX_rg_ld_val$write_1__SEL_1 ?
	       MUX_rg_ld_val$write_1__VAL_1 :
	       64'd1 ;
  assign rg_ld_val$EN =
	     WILL_FIRE_RL_rl_read_rsp && f_read_data$D_OUT[64] ||
	     WILL_FIRE_RL_rl_AMO_SC ;

  // register rg_pa
  assign rg_pa$D_IN = start_pa ;
  assign rg_pa$EN = EN_start ;

  // register rg_req
  assign rg_req$D_IN = req_mmu_cache_req ;
  assign rg_req$EN = EN_req ;

  // submodule f_read_data
  assign f_read_data$D_IN = p_mem_read_data_put ;
  assign f_read_data$ENQ = EN_p_mem_read_data_put ;
  assign f_read_data$DEQ = CAN_FIRE_RL_rl_read_rsp ;
  assign f_read_data$CLR = 1'b0 ;

  // submodule f_single_reqs
  always@(MUX_f_single_reqs$enq_1__SEL_1 or
	  MUX_f_single_reqs$enq_1__VAL_1 or
	  WILL_FIRE_RL_rl_write_req or
	  WILL_FIRE_RL_rl_read_req or MUX_f_single_reqs$enq_1__VAL_3)
  begin
    case (1'b1) // synopsys parallel_case
      MUX_f_single_reqs$enq_1__SEL_1:
	  f_single_reqs$D_IN = MUX_f_single_reqs$enq_1__VAL_1;
      WILL_FIRE_RL_rl_write_req:
	  f_single_reqs$D_IN = MUX_f_single_reqs$enq_1__VAL_1;
      WILL_FIRE_RL_rl_read_req:
	  f_single_reqs$D_IN = MUX_f_single_reqs$enq_1__VAL_3;
      default: f_single_reqs$D_IN =
		   67'h2AAAAAAAAAAAAAAAA /* unspecified value */ ;
    endcase
  end
  assign f_single_reqs$ENQ =
	     WILL_FIRE_RL_rl_read_rsp && f_read_data$D_OUT[64] &&
	     rg_req[207:206] != 2'd0 &&
	     (rg_req[207:206] != 2'd2 || rg_req[74:70] != 5'b00010) ||
	     WILL_FIRE_RL_rl_write_req ||
	     WILL_FIRE_RL_rl_read_req ;
  assign f_single_reqs$DEQ = EN_g_mem_req_get ;
  assign f_single_reqs$CLR = 1'b0 ;

  // submodule f_write_data
  assign f_write_data$D_IN =
	     MUX_f_single_reqs$enq_1__SEL_1 ?
	       MUX_f_write_data$enq_1__VAL_1 :
	       MUX_f_write_data$enq_1__VAL_2 ;
  assign f_write_data$ENQ =
	     WILL_FIRE_RL_rl_read_rsp && f_read_data$D_OUT[64] &&
	     rg_req[207:206] != 2'd0 &&
	     (rg_req[207:206] != 2'd2 || rg_req[74:70] != 5'b00010) ||
	     WILL_FIRE_RL_rl_write_req ;
  assign f_write_data$DEQ = EN_g_write_data_get ;
  assign f_write_data$CLR = 1'b0 ;

  // remaining internal signals
  assign IF_rg_req_BITS_204_TO_203_8_EQ_0b10_4_THEN_SEX_ETC___d80 =
	     (rg_req[204:203] == 2'b10) ?
	       { {32{rg_req_BITS_106_TO_75__q3[31]}},
		 rg_req_BITS_106_TO_75__q3 } :
	       rg_req[138:75] ;
  assign data1__h978 = f_read_data$D_OUT[63:0] >> shamt_bits__h1918 ;
  assign data__h1908 = rg_req[138:75] & mask__h1023 ;
  assign final_ld_val__h1356 =
	     (rg_req[204:203] == 2'b10) ?
	       { {32{ld_val_bits89_BITS_31_TO_0__q1[31]}},
		 ld_val_bits89_BITS_31_TO_0__q1 } :
	       ld_val_bits__h789 ;
  assign final_st_val__h1357 =
	     (rg_req[204:203] == 2'b10) ?
	       final_st_val__h1473 :
	       _theResult_____2__h1449 ;
  assign final_st_val__h1473 = { 32'd0, _theResult_____2__h1449[31:0] } ;
  assign final_st_val__h1563 =
	     final_ld_val__h1356 +
	     IF_rg_req_BITS_204_TO_203_8_EQ_0b10_4_THEN_SEX_ETC___d80 ;
  assign final_st_val__h1641 = w1__h1442 ^ w2__h1444 ;
  assign final_st_val__h1645 = w1__h1442 & w2__h1444 ;
  assign final_st_val__h1649 = w1__h1442 | w2__h1444 ;
  assign final_st_val__h1653 =
	     (w1__h1442 < w2__h1444) ? w1__h1442 : w2__h1444 ;
  assign final_st_val__h1658 =
	     (w1__h1442 <= w2__h1444) ? w2__h1444 : w1__h1442 ;
  assign final_st_val__h1664 =
	     ((final_ld_val__h1356 ^ 64'h8000000000000000) <
	      (IF_rg_req_BITS_204_TO_203_8_EQ_0b10_4_THEN_SEX_ETC___d80 ^
	       64'h8000000000000000)) ?
	       w1__h1442 :
	       w2__h1444 ;
  assign final_st_val__h1669 =
	     ((final_ld_val__h1356 ^ 64'h8000000000000000) <=
	      (IF_rg_req_BITS_204_TO_203_8_EQ_0b10_4_THEN_SEX_ETC___d80 ^
	       64'h8000000000000000)) ?
	       w2__h1444 :
	       w1__h1442 ;
  assign ld_val__h870 =
	     (!rg_req[205] &&
	      CASE_rg_req_BITS_204_TO_203_0b0_ld_val_bits89__ETC__q2) ?
	       result__h1242 :
	       result__h1314 ;
  assign ld_val_bits89_BITS_31_TO_0__q1 = ld_val_bits__h789[31:0] ;
  assign ld_val_bits__h789 = data1__h978 & mask__h1023 ;
  assign result__h1242 = ld_val_bits__h789 | y__h1254 ;
  assign result__h1314 = ld_val_bits__h789 & mask__h1023 ;
  assign rg_req_BITS_106_TO_75__q3 = rg_req[106:75] ;
  assign shamt_bits__h1918 = { rg_pa[2:0], 3'b0 } ;
  assign w1___1__h1532 = { 32'd0, ld_val_bits__h789[31:0] } ;
  assign w1__h1442 =
	     (rg_req[204:203] == 2'b10) ? w1___1__h1532 : ld_val_bits__h789 ;
  assign w2___1__h1533 = { 32'd0, rg_req[106:75] } ;
  assign w2__h1444 =
	     (rg_req[204:203] == 2'b10) ? w2___1__h1533 : rg_req[138:75] ;
  always@(rg_req)
  begin
    case (rg_req[204:203])
      2'b0: mask__h1023 = 64'h00000000000000FF;
      2'b01: mask__h1023 = 64'h000000000000FFFF;
      2'b10: mask__h1023 = 64'h00000000FFFFFFFF;
      2'd3: mask__h1023 = 64'hFFFFFFFFFFFFFFFF;
    endcase
  end
  always@(rg_req)
  begin
    case (rg_req[204:203])
      2'b0: y__h1254 = 64'hFFFFFFFFFFFFFF00;
      2'b01: y__h1254 = 64'hFFFFFFFFFFFF0000;
      2'b10: y__h1254 = 64'hFFFFFFFF00000000;
      2'd3: y__h1254 = 64'd0;
    endcase
  end
  always@(rg_req or ld_val_bits__h789)
  begin
    case (rg_req[204:203])
      2'b0:
	  CASE_rg_req_BITS_204_TO_203_0b0_ld_val_bits89__ETC__q2 =
	      ld_val_bits__h789[7];
      2'b01:
	  CASE_rg_req_BITS_204_TO_203_0b0_ld_val_bits89__ETC__q2 =
	      ld_val_bits__h789[15];
      2'b10:
	  CASE_rg_req_BITS_204_TO_203_0b0_ld_val_bits89__ETC__q2 =
	      ld_val_bits__h789[31];
      2'd3:
	  CASE_rg_req_BITS_204_TO_203_0b0_ld_val_bits89__ETC__q2 =
	      ld_val_bits__h789[63];
    endcase
  end
  always@(rg_req or
	  final_st_val__h1669 or
	  final_st_val__h1563 or
	  w2__h1444 or
	  final_st_val__h1641 or
	  final_st_val__h1649 or
	  final_st_val__h1645 or
	  final_st_val__h1664 or final_st_val__h1653 or final_st_val__h1658)
  begin
    case (rg_req[74:70])
      5'b0: _theResult_____2__h1449 = final_st_val__h1563;
      5'b00001: _theResult_____2__h1449 = w2__h1444;
      5'b00100: _theResult_____2__h1449 = final_st_val__h1641;
      5'b01000: _theResult_____2__h1449 = final_st_val__h1649;
      5'b01100: _theResult_____2__h1449 = final_st_val__h1645;
      5'b10000: _theResult_____2__h1449 = final_st_val__h1664;
      5'b11000: _theResult_____2__h1449 = final_st_val__h1653;
      5'b11100: _theResult_____2__h1449 = final_st_val__h1658;
      default: _theResult_____2__h1449 = final_st_val__h1669;
    endcase
  end

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        rg_err <= `BSV_ASSIGNMENT_DELAY 1'd0;
	rg_final_st_val <= `BSV_ASSIGNMENT_DELAY 64'd0;
	rg_fsm_state <= `BSV_ASSIGNMENT_DELAY 2'd0;
	rg_ld_val <= `BSV_ASSIGNMENT_DELAY 64'd0;
      end
    else
      begin
        if (rg_err$EN) rg_err <= `BSV_ASSIGNMENT_DELAY rg_err$D_IN;
	if (rg_final_st_val$EN)
	  rg_final_st_val <= `BSV_ASSIGNMENT_DELAY rg_final_st_val$D_IN;
	if (rg_fsm_state$EN)
	  rg_fsm_state <= `BSV_ASSIGNMENT_DELAY rg_fsm_state$D_IN;
	if (rg_ld_val$EN) rg_ld_val <= `BSV_ASSIGNMENT_DELAY rg_ld_val$D_IN;
      end
    if (rg_pa$EN) rg_pa <= `BSV_ASSIGNMENT_DELAY rg_pa$D_IN;
    if (rg_req$EN) rg_req <= `BSV_ASSIGNMENT_DELAY rg_req$D_IN;
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    rg_err = 1'h0;
    rg_final_st_val = 64'hAAAAAAAAAAAAAAAA;
    rg_fsm_state = 2'h2;
    rg_ld_val = 64'hAAAAAAAAAAAAAAAA;
    rg_pa = 64'hAAAAAAAAAAAAAAAA;
    rg_req = 208'hAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkMMIO

